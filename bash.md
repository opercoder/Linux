## Команды, аргументы, встроенные функции и ключевые слова
Команды, которые вы можете запустить, определяют либо файлы, либо встроенные функции, либо ключевые слова.  
1. **Файлы (file)** — это исполняемые приложения, которые становятся результатом компиляции и теперь состоят из машинных команд. Примером подобного приложения
служит программа ls. Другой тип файла — это скрипт. Это текстовый файл, который может прочесть
человек. Скрипт пишется на одном из языков, поддерживаемых вашей системой,
с помощью интерпретатора (программы) для этого языка. Примерами языков для
написания скриптов могут служить bash, Python и Perl.  
``` bash 
$ type -t ls
file
compgen -c #Показать список команд (файлов)
```
2. **Встроенные функции (builtin)** — это часть оболочки. Они выглядят как исполняемые
файлы, но в файловой системе нет файла, который загружается для исполнения
того, что делают встроенные функции. Вместо этого работа выполняется внутри
оболочки. Примером встроенной функции служит команда pwd. Применение таких
функций позволит добиться результатов быстрее и с большей продуктивностью.
Как пользователь, вы можете определять наиболее часто используемые функции
оболочки как встроенные команды.  
``` bash
$ type -t pwd
builtin
compgen -b #Показать список встроенных функций
```
3. **Ключевые слова (keyword)** — выглядят как команды, но на самом деле
являются частью языка оболочки, например if. Это слово часто используется
в качестве первого слова в командной строке, но это не команда. Это ключевое 
слово. Оно связано с синтаксисом, который может быть сложнее, чем обычный
формат командной строки: команда -опции аргументы.  
``` bash 
$ type -t if
keyword
compgen -k #Показать список ключевых слов 
```
## Стандартные ввод/вывод/ошибка
На жаргоне специалистов по операционным системам запущенная программа называется процессом. Каждый процесс в среде Unix/Linux/POSIX (и, следовательно,
в Windows) обладает тремя различными файловыми дескрипторами.  
Дескрипторам присвоены следующие названия: стандартный ввод (сокращенно **stdin**), стандартный вывод (**stdout**) и стандартная ошибка (**stderr**).  
При перенаправлении данных, выводимых программой, нужно различать stdout и stderr, и мы создаем
это различие с помощью номеров файловых дескрипторов. Stdin — это файловый дескриптор 0, stdout — файловый дескриптор 1, а stderr — файловый дескриптор 2.  
``` bash
somecommand < data.in > results.out 2> err.msgs # Направлять вывод в файлы, а ввод брать из файла
somecommand < data.in > results.out 2>&1        # Объединить stdout и stderr
somecommand < data.in &> results.out            # Объединить stdout и stderr
somecommand < data.in > /dev/null               # Отсеять стандартный вывод stdout
somecommand < data.in | tee results.out         # Выводить результат на экран и писать в файл
somecommand < data.in &>> results.out           # Добавить stdout и stderr в файл, не перезаписывая его
```
## Выполнение команд в фоновом режиме
Команды могут выполняться в течение довольно длительного времени. Чтобы запустить любую команду или сценарий в фоновом режиме, используйте оператор &.  
Скрипт будет выполняться дальше, но вы сможете продолжать использовать оболочку, давая другие команды и/или выполняя другие сценарии.  
``` bash
ping 10.0.0.1 > ping.log &
ping 10.0.0.1 &> ping.log &
```
Для получения списка задач, которые выполняются в фоновом режиме можно использовать команду jobs:
``` bash
$ jobs
[1]+ Running      ping 10.0.0.1 > ping.log &
```
Чтобы снова вывести задачу в приоритет:
``` bash
$ fg 1
ping 10.0.0.1 > ping.log
```
Для приостановки процесса можно нажать **Ctrl+Z**. Для продолжения работы в фоновом режиме введите **bg**.  
## От командной строки до скрипта
Скрипт оболочки — это просто файл, содержащий команды, которые вы можете последовательно ввести в командную строку. Если ввести одну команду или более в файл, получится скрипт оболочки. Если вы, например, назовете этот файл myscript,
его можно будет запустить, введя команду bash myscript. Кроме того, можете наделить его полномочиями на выполнение
(например, chmod 755 myscript), а затем, чтобы управлять сценарием, вызывать его напрямую: ./myscript. Следующая строка,
сообщающая операционной системе, какой язык скриптов мы используем, часто становится первой строкой скрипта:  
``` bash
#!/bin/bash -  
```
Конечно, в этой строке предполагается, что bash находится в каталоге /bin.
Если вам потребуется сделать скрипт более мобильным, можно воспользоваться следующим подходом:  
``` bash
#!/usr/bin/env bash  
```
Здесь, чтобы найти местонахождение bash, используется команда env. Этот способ
считается стандартным методом решения проблемы мобильности. Однако в данном
случае предполагается, что команду env можно найти в каталоге /usr/bin.
## Вывод
Как и любой другой язык программирования, bash имеет возможность выводить
информацию на экран. Вывод можно успешно выполнить с помощью команды echo:
``` bash
$ echo "Hello World"
Hello World
```
Вы также можете использовать встроенную команду printf, которая позволяет
добавить дополнительное форматирование:
``` bash
$ printf "Hello World\n"
Hello World
```
## Переменные
Переменные bash начинаются с буквенного символа или символа подчеркивания,
за которым следуют алфавитно-цифровые символы. Они являются строковыми,
если не указано иное. Чтобы присвоить значение переменной, вы пишете что-то
вроде этого:
``` bash
MYVAR=textforavalue
```
Чтобы извлечь значение этой переменной (например, вывести на экран с помощью
команды _echo_), вы задаете $ перед именем переменной:
``` bash
echo $MYVAR
```
Если вы хотите присвоить переменной последовательность слов, то есть сохранить
все пробелы, то заключите значение в кавычки:  
``` bash
MYVAR='here is a longer set of words'
OTHRV="either double or single quotes will work"
```
Использование двойных кавычек позволит выполнять другие замены внутри
строки. Например:
``` bash
firstvar=beginning
secondvr="this is just the $firstvar"
echo $secondvr
```
В результате мы получаем на выходе такое значение переменной _firstvar_:  
_this is just the beginning_  
ВАЖНО: при использовании двойных кавычек (") любые замены, начинающиеся с $,
все равно выполняются, а если значение находится внутри одинарных кавычек ('), никаких замен не будет.  
Вы также можете сохранить вывод, полученный командой оболочки, с помощью
символов **$( )**, как показано ниже:
``` bash
CMDOUT=$(pwd)
```
Здесь команда pwd выполняется в подоболочке, и вместо того, чтобы печатать
результат в stdout, мы сохраняем вывод команды в переменной CMDOUT. Вы также
можете передать вместе несколько команд внутри $( ).  
#### Позиционные параметры. 
Обычно при использовании инструментов командной строки для передачи данных в команды применяются аргументы или параметры.
Каждый параметр отделяется пробелом и доступен внутри bash с помощью специального набора идентификаторов. В скрипте bash доступ к первому параметру, переданному в скрипт, можно получить с помощью **$1**, ко второму — с **$2** и т. д.
**$0** — это специальный параметр, который содержит имя скрипта, а  
**$#** возвращает общее количество параметров.




