## Команды, аргументы, встроенные функции и ключевые слова
Команды, которые вы можете запустить, определяют либо файлы, либо встроенные функции, либо ключевые слова.  
1. **Файлы (file)** — это исполняемые приложения, которые становятся результатом компиляции и теперь состоят из машинных команд. Примером подобного приложения
служит программа ls. Другой тип файла — это скрипт. Это текстовый файл, который может прочесть
человек. Скрипт пишется на одном из языков, поддерживаемых вашей системой,
с помощью интерпретатора (программы) для этого языка. Примерами языков для
написания скриптов могут служить bash, Python и Perl.  
``` bash 
$ type -t ls
file
compgen -c #Показать список команд (файлов)
```
2. **Встроенные функции (builtin)** — это часть оболочки. Они выглядят как исполняемые
файлы, но в файловой системе нет файла, который загружается для исполнения
того, что делают встроенные функции. Вместо этого работа выполняется внутри
оболочки. Примером встроенной функции служит команда pwd. Применение таких
функций позволит добиться результатов быстрее и с большей продуктивностью.
Как пользователь, вы можете определять наиболее часто используемые функции
оболочки как встроенные команды.  
``` bash 
$ type -t pwd
builtin
compgen -b #Показать список встроенных функций
```
3. **Ключевые слова (keyword)** — выглядят как команды, но на самом деле
являются частью языка оболочки, например if. Это слово часто используется
в качестве первого слова в командной строке, но это не команда. Это ключевое 
слово. Оно связано с синтаксисом, который может быть сложнее, чем обычный
формат командной строки: команда -опции аргументы.  
``` bash 
$ type -t if
keyword
compgen -k #Показать список ключевых слов 
```
## Стандартные ввод/вывод/ошибка
На жаргоне специалистов по операционным системам запущенная программа называется процессом. Каждый процесс в среде Unix/Linux/POSIX (и, следовательно,
в Windows) обладает тремя различными файловыми дескрипторами.  
Дескрипторам присвоены следующие названия: стандартный ввод (сокращенно **stdin**), стандартный вывод (**stdout**) и стандартная ошибка (**stderr**).  
При перенаправлении данных, выводимых программой, нужно различать stdout и stderr, и мы создаем
это различие с помощью номеров файловых дескрипторов. Stdin — это файловый дескриптор 0, stdout — файловый дескриптор 1, а stderr — файловый дескриптор 2.  
``` bash
somecommand < data.in > results.out 2> err.msgs # Направлять вывод в файлы, а ввод брать из файла
somecommand < data.in > results.out 2>&1        # Объединить stdout и stderr
somecommand < data.in &> results.out            # Объединить stdout и stderr
somecommand < data.in > /dev/null               # Отсеять стандартный вывод stdout
somecommand < data.in | tee results.out         # Выводить результат на экран и писать в файл
somecommand < data.in &>> results.out           # Добавить stdout и stderr в файл, не перезаписывая его
```
## Выполнение команд в фоновом режиме
Команды могут выполняться в течение довольно длительного времени. Чтобы запустить любую команду или сценарий в фоновом режиме, используйте оператор &.  
Скрипт будет выполняться дальше, но вы сможете продолжать использовать оболочку, давая другие команды и/или выполняя другие сценарии.  
``` bash
ping 10.0.0.1 > ping.log &
ping 10.0.0.1 &> ping.log &
```
Для получения списка задач, которые выполняются в фоновом режиме можно использовать команду jobs:
``` bash
$ jobs
[1]+ Running      ping 10.0.0.1 > ping.log &
```
Чтобы снова вывести задачу в приоритет:
``` bash
$ fg 1
ping 10.0.0.1 > ping.log
```
Для приостановки процесса можно нажать **Ctrl+Z**. Для продолжения работы в фоновом режиме введите **bg**.  


